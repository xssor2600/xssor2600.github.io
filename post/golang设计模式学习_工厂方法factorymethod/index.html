<!DOCTYPE html>
<html lang="en-us">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<style type=text/css>body{font-family:monospace;}</style>
	<title>Golang设计模式学习_工厂方法FactoryMethod</title>
	<meta name="description" content="老夫聊发少年狂~">
	
	<link rel="stylesheet" href="/css/style.css">
	
</head>
<body>
	<header>
	==============================<br>
	== <a href="https://www.xssor2600.site/">琳琅世界，观山河</a> ==<br>
	==============================
	<div style="float: right;">前三三x后三三</div><br>
	<p>
	<nav>
			<a href="/"><b>[Start]</b></a>.
			
			
			<a href="/post/"><b>[Posts]</b></a>.
			
			<a href="/categories/"><b>[Categories]</b></a>.
			
			<a href="/tags/"><b>[Tags]</b></a>.
			
			<a href="/minds/"><b>[随想杂记]</b></a>.
			
	</nav>
	</p>
	
    <img src="https://s1.ax1x.com/2020/07/04/Nx6Ots.png" alt="Nx6Ots.png" border="0" width="75" height="70"/>
</header>

	
	<main>
		<article>
			<h1>Golang设计模式学习_工厂方法FactoryMethod</h1>
			<b><time>2020.07.26 23:01</time></b>
		       
		           <a href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F">设计模式</a>
        	       
		           <a href="/tags/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95">工厂方法</a>
        	       
                   </br>
                   </br>[content:] start~</br>
			<div>
				<h4 id="工厂方法模式理论">工厂方法模式理论</h4>
<ol>
<li>
<p>为什么需要工厂方法模式？</p>
<p>工厂方法模式也是一种创建型模式，产生的目的就是为了“创建对象”。那么为什么需要这种模式来创建对象，创建哪些场景的对象呢？工厂方法模式也是为了适应软件设计<code>开闭原则，依赖倒置原则</code>的，目的就是通过一种工程化方式，设计可拓展的程序。<strong>面向接口开发。不需要太多的关注实现细节</strong></p>
<blockquote>
<p>定义一个用于创建对象的接口，让子类绝对实例化哪一个类，工厂方法使一个类的实例化延迟到其子类。
总是引用接口而非实现类，能允许变换子类而不影响调用方，即尽可能面向抽象编程。</p>
</blockquote>
<p>在OOP中，通常都会有<code>抽象</code>的概念，通常在高级语言中，会通过内建的一些关键字进行表达，例如<code>abstrct,interface...</code>,目的就是让开发者通过这些抽象，去设计高可拓展，稳定的程序。</p>
<p>例如在Java中，如果不是面向接口（抽象）去创建产品，那么在对象的创建过程，和对象的使用过程都会有局限性，因为太过于具体而不利于拓展。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#75715e">// 例如有两个实体
</span><span style="color:#75715e"></span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">ProductA</span> <span style="color:#f92672">{</span>
     
<span style="color:#f92672">}</span>
   
<span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">ProductB</span> <span style="color:#f92672">{</span>
     
<span style="color:#f92672">}</span>
   
<span style="color:#75715e">// 要打印所有的商品
</span><span style="color:#75715e"></span><span style="color:#66d9ef">public</span> Class ProductPrinter <span style="color:#f92672">{</span>
  <span style="color:#75715e">// 为了突出目的，不用重写
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">printA</span><span style="color:#f92672">(</span>ProductA pa<span style="color:#f92672">){</span>
       
  <span style="color:#f92672">}</span>
  <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">printB</span><span style="color:#f92672">(</span>ProductB pb<span style="color:#f92672">){</span>
       
  <span style="color:#f92672">}</span>
     
  <span style="color:#75715e">// ...  public void print(ProductB pb){
</span><span style="color:#75715e"></span>       
 <span style="color:#75715e">//}
</span><span style="color:#75715e"></span><span style="color:#f92672">}</span>
   
<span style="color:#75715e">// 常规创建对象
</span><span style="color:#75715e"></span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span><span style="color:#f92672">(</span>String<span style="color:#f92672">[]</span> args<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
  ProductA a <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> ProductA<span style="color:#f92672">();</span> 
  ProductB b <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> ProductB<span style="color:#f92672">();</span>
  <span style="color:#75715e">// ProductC c = new ProductC();
</span><span style="color:#75715e"></span>     
  ProductPrinter printer <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> ProductPrinter<span style="color:#f92672">();</span>
  printer<span style="color:#f92672">.</span><span style="color:#a6e22e">printA</span><span style="color:#f92672">(</span>a<span style="color:#f92672">);</span> <span style="color:#75715e">// 分别调用两个方法
</span><span style="color:#75715e"></span>  printer<span style="color:#f92672">.</span><span style="color:#a6e22e">printB</span><span style="color:#f92672">(</span>b<span style="color:#f92672">);</span>
<span style="color:#f92672">}</span>
</code></pre></div><p>可以看到，两种相似的产品，需要分别使用产品对象进行创建，在产品打印类中，若是想要打印所有产品，还得分别定义多个方法。不利于拓展，并且当有新的产品添加的时候，代码改动地方会很多，有风险。</p>
<p>当使用了面向接口编程，类似使用了工厂方法来创建对象，那么，代码可拓展型，稳定性就会变得很高：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#75715e">// 例如有两个实体,Product是所有产品的抽象
</span><span style="color:#75715e"></span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">ProductA</span> <span style="color:#66d9ef">implements</span> Product <span style="color:#f92672">{</span>
     
<span style="color:#f92672">}</span>
   
<span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">ProductB</span>  <span style="color:#66d9ef">implements</span> Product <span style="color:#f92672">{</span>
     
<span style="color:#f92672">}</span>
   
<span style="color:#66d9ef">public</span> Class ProductPrinter <span style="color:#f92672">{</span>
  <span style="color:#75715e">// 面向抽象作为入参传入,不用关心细节
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">print</span><span style="color:#f92672">(</span>Product p<span style="color:#f92672">){</span>
       
  <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
   
<span style="color:#75715e">// 工厂方法，根据不同需求创建不同对象
</span><span style="color:#75715e"></span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">ProductFactoryMethod</span> <span style="color:#f92672">{</span>
  <span style="color:#66d9ef">private</span> Product product<span style="color:#f92672">;</span>
     
  <span style="color:#75715e">// 根据不同需求工厂方法newProduct创建不同的对象
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">public</span> Product <span style="color:#a6e22e">newProduct</span><span style="color:#f92672">(</span>string productType<span style="color:#f92672">){</span>
    <span style="color:#66d9ef">if</span> <span style="color:#e6db74">&#34;pa&#34;</span><span style="color:#f92672">.</span><span style="color:#a6e22e">equals</span><span style="color:#f92672">(</span>productType<span style="color:#f92672">){</span>
      product <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> ProductA<span style="color:#f92672">();</span>
    <span style="color:#f92672">}</span><span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> <span style="color:#e6db74">&#34;pb&#34;</span><span style="color:#f92672">.</span><span style="color:#a6e22e">equals</span><span style="color:#f92672">(</span>productType<span style="color:#f92672">){</span>
      product <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> ProductB<span style="color:#f92672">();</span>
    <span style="color:#f92672">}</span>
    <span style="color:#66d9ef">return</span> product<span style="color:#f92672">;</span>
  <span style="color:#f92672">}</span>
     
<span style="color:#f92672">}</span>
   
   
   
<span style="color:#75715e">// 客户端调用代码复用性高，不用对变动进行大改
</span><span style="color:#75715e"></span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span><span style="color:#f92672">(</span>String<span style="color:#f92672">[]</span> args<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
  ProductFactoryMethod factory <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> ProductFactoryMethod<span style="color:#f92672">();</span>
  ProductA a <span style="color:#f92672">=</span> factory<span style="color:#f92672">.</span><span style="color:#a6e22e">newProduct</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;pa&#34;</span><span style="color:#f92672">)</span>
  ProductB b <span style="color:#f92672">=</span> factory<span style="color:#f92672">.</span><span style="color:#a6e22e">newProduct</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;pb&#34;</span><span style="color:#f92672">)</span>
  <span style="color:#75715e">// ProductC c = new ProductC();
</span><span style="color:#75715e"></span>     
  ProductPrinter printer <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> ProductPrinter<span style="color:#f92672">();</span>
  printer<span style="color:#f92672">.</span><span style="color:#a6e22e">print</span><span style="color:#f92672">(</span>a<span style="color:#f92672">);</span>
  printer<span style="color:#f92672">.</span><span style="color:#a6e22e">print</span><span style="color:#f92672">(</span>b<span style="color:#f92672">);</span>
<span style="color:#f92672">}</span>
   
</code></pre></div></li>
<li>
<p>工厂方法有哪些组成？</p>
<ul>
<li>抽象产品类Product：负责定义产品的共性，实现对事物最抽象的定义</li>
<li>Creator为抽象类创建类：是抽象工厂，具体如何创建产品类是有具体的实现工厂ConcreteCreator完成的。</li>
</ul>
<p>基本就是两大类：产品对象Product + 抽象工厂，都是面向抽象编程。</p>
<p>具体根据不同实现方式，其实在Java中还区分划出了<code>静态工厂方法，抽象工厂模式</code>等等。</p>
</li>
<li>
<p>工厂方法有哪些应用的套路？</p>
<p>抽象好产品Product，产品不一定非要是<code>struct</code>类型的，也可以是<code>interface</code>类型的。</p>
<p>定义好抽象工厂，抽象工厂通常是<code>interface</code>类型的，接口内包含返回Product的方法（返回通常是interface，而不是struct)</p>
<blockquote>
<p>抽象的Product通常是struct+interface组合形成的抽象对象。</p>
</blockquote>
</li>
<li>
<p>工厂方法的优缺点？</p>
<ul>
<li>
<p>优点</p>
<p>把初始化实例时的工作放到工厂里进行，使代码更容易维护。 更符合面向对象的原则，面向接口编程，而不是面向实现编程。</p>
</li>
<li>
<p>缺点</p>
<p>每次增加一个产品时，都需要增加一个具体类和对象实现工厂，使得系统中类的个数成倍增加，在一定程度上增加了系统的复杂度，同时也增加了系统具体类的依赖。要新增产品类的时候，就要修改工厂类的代码，违反了开放封闭原则。</p>
</li>
</ul>
</li>
</ol>
<h4 id="工厂模式实践应用">工厂模式实践应用</h4>
<h5 id="go中应用">Go中应用</h5>
<blockquote>
<p>在golang中，工厂模式的应用最核心的一点就是：需要将常规的封装（属性+方法）进行拆分。</p>
<p>struct（属性定义） + interface（方法定义） =&gt; struct需要实现interface的方法。</p>
</blockquote>
<ul>
<li>
<p>简单工厂模式
简而言之，就是通过客户端传入内容，工厂进行判断，返回对应的产品对象。</p>
<ol>
<li>
<p>定义产品抽象，<strong>重点是对产品共同行为进行抽象</strong>。
假设设定抽象产品是：操作运算符。根据不同符号进行不同操作（创建不同的操作符对象）</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#75715e">// 加分操作符对象Product
</span><span style="color:#75715e"></span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">AddOperate</span> <span style="color:#66d9ef">struct</span> {
}
     
<span style="color:#75715e">// 乘法操作符对象Product
</span><span style="color:#75715e"></span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">MultipleOperate</span> <span style="color:#66d9ef">struct</span> {
}
</code></pre></div><p>都是二元运算符，相同的行为就是：<code>根据两个参数进行运算操作</code></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#75715e">// 在golang中的行为抽象就是定义interface
</span><span style="color:#75715e"></span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Operater</span> <span style="color:#66d9ef">interface</span> {
    <span style="color:#a6e22e">Operate</span>(<span style="color:#66d9ef">int</span>, <span style="color:#66d9ef">int</span>) <span style="color:#66d9ef">int</span>
}
     
<span style="color:#75715e">// golang中需要产品Product实现interface方法，才能成为完整的面向对象
</span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">this</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">AddOperate</span>) <span style="color:#a6e22e">Operate</span>(<span style="color:#a6e22e">rhs</span> <span style="color:#66d9ef">int</span>, <span style="color:#a6e22e">lhs</span> <span style="color:#66d9ef">int</span>) <span style="color:#66d9ef">int</span> {
    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">rhs</span> <span style="color:#f92672">+</span> <span style="color:#a6e22e">lhs</span>
}
     
<span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">this</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">MultipleOperate</span>) <span style="color:#a6e22e">Operate</span>(<span style="color:#a6e22e">rhs</span> <span style="color:#66d9ef">int</span>, <span style="color:#a6e22e">lhs</span> <span style="color:#66d9ef">int</span>) <span style="color:#66d9ef">int</span> {
    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">rhs</span> <span style="color:#f92672">*</span> <span style="color:#a6e22e">lhs</span>
}
     
     
</code></pre></div></li>
<li>
<p>定义抽象工厂，根据不同的内容创建不同对象
通常简单工厂模式，就是<code>通过单个工厂类，去创建多个不同的对象Product</code>,改种弊端就是若是新增产品，那么必须在工厂类中需要修改，新建分支。</p>
<blockquote>
<p>这里需要注意的一点是：工厂方法创建的对象不是传统Java中的Product，在golang中，工厂方法返回的是Product中具有相同行为的抽象，即为方法=&gt; interface</p>
</blockquote>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#75715e">// 定义抽象工厂包含： struct + interface（创建产品方法）
</span><span style="color:#75715e"></span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">OperateFactory</span> <span style="color:#66d9ef">struct</span> {
}
     
<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">NewOperateFactory</span>() <span style="color:#f92672">*</span><span style="color:#a6e22e">OperateFactory</span> {
    <span style="color:#66d9ef">return</span> <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">OperateFactory</span>{}
}
     
<span style="color:#75715e">// 定义简单工厂创建不同的product的方法,这里返回的不是Product，而是Product&#39;s 方法
</span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">this</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">OperateFactory</span>) <span style="color:#a6e22e">CreateOperate</span>(<span style="color:#a6e22e">operatename</span> <span style="color:#66d9ef">string</span>) <span style="color:#a6e22e">Operater</span> {
    <span style="color:#66d9ef">switch</span> <span style="color:#a6e22e">operatename</span> {
    <span style="color:#66d9ef">case</span> <span style="color:#e6db74">&#34;+&#34;</span>:
        <span style="color:#66d9ef">return</span> <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">AddOperate</span>{}
    <span style="color:#66d9ef">case</span> <span style="color:#e6db74">&#34;*&#34;</span>:
        <span style="color:#66d9ef">return</span> <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">MultipleOperate</span>{}
    <span style="color:#66d9ef">default</span>:
        panic(<span style="color:#e6db74">&#34;无效运算符号&#34;</span>)
        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nil</span>
    }
}
     
</code></pre></div></li>
<li>
<p>使用方式Usage</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
    <span style="color:#75715e">// 创建工厂对象，并根据传入内容进行创建具体的Product
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">Operator</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">NewOperateFactory</span>().<span style="color:#a6e22e">CreateOperate</span>(<span style="color:#e6db74">&#34;+&#34;</span>)
    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;add result is %d\n&#34;</span>, <span style="color:#a6e22e">Operator</span>.<span style="color:#a6e22e">Operate</span>(<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>))
}
</code></pre></div></li>
</ol>
</li>
<li>
<p>工厂方法模式</p>
<p>与简单工厂模式不同，工厂方法模式：<code>每个具体工厂类只负责创建对应的产品</code>,也就是产品Product与Factory工厂是一一对应的。好处就是，不像简单工厂模式，新建产品Product还是需要修改单一的工厂方法，而工厂方法模式因为产品与工厂是一一对应，则不需要改动之前的产品代码。</p>
<blockquote>
<p>每一种产品Product都会有具体的Factory与之对应，具体的Factory来创建具体的产品。</p>
</blockquote>
<ol>
<li>
<p>定义抽象产品Product，不同的具体产品需要继承该产品。</p>
<p>在golang中，对抽象产品Product的继承，就是通过<code>将一个struct，作为属性定义在子类struct中</code>.通过<strong>struct+interface</strong>组合成了<code>封装</code>的概念。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#75715e">// 抽象产品对象，二元操作数
</span><span style="color:#75715e"></span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Operation</span> <span style="color:#66d9ef">struct</span> {
    <span style="color:#a6e22e">a</span> <span style="color:#66d9ef">float64</span>
    <span style="color:#a6e22e">b</span> <span style="color:#66d9ef">float64</span>
}
     
<span style="color:#75715e">// 抽象的产品行为
</span><span style="color:#75715e"></span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">OperationI</span> <span style="color:#66d9ef">interface</span> {
    <span style="color:#a6e22e">GetResult</span>() <span style="color:#66d9ef">float64</span>
    <span style="color:#a6e22e">SetA</span>(<span style="color:#66d9ef">float64</span>)
    <span style="color:#a6e22e">SetB</span>(<span style="color:#66d9ef">float64</span>)
}
     
     
<span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">op</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">Operation</span>) <span style="color:#a6e22e">SetA</span>(<span style="color:#a6e22e">a</span> <span style="color:#66d9ef">float64</span>) {
    <span style="color:#a6e22e">op</span>.<span style="color:#a6e22e">a</span> = <span style="color:#a6e22e">a</span>
}
     
<span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">op</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">Operation</span>) <span style="color:#a6e22e">SetB</span>(<span style="color:#a6e22e">b</span> <span style="color:#66d9ef">float64</span>) {
    <span style="color:#a6e22e">op</span>.<span style="color:#a6e22e">b</span> = <span style="color:#a6e22e">b</span>
}
     
</code></pre></div><p>针对不同的操作运算符对象（+-*/）就是不同的具体的子产品。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#75715e">// 加法产品，通过将抽象的产品作为属性继承
</span><span style="color:#75715e"></span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">AddOperation</span> <span style="color:#66d9ef">struct</span> {
    <span style="color:#a6e22e">Operation</span>
}
<span style="color:#75715e">// 多态的实现抽象产品中的行为
</span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">this</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">AddOperation</span>) <span style="color:#a6e22e">GetResult</span>() <span style="color:#66d9ef">float64</span> {
    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">this</span>.<span style="color:#a6e22e">a</span> <span style="color:#f92672">+</span> <span style="color:#a6e22e">this</span>.<span style="color:#a6e22e">b</span>
}
     
     
<span style="color:#75715e">// 减法
</span><span style="color:#75715e"></span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">SubOperation</span> <span style="color:#66d9ef">struct</span> {
    <span style="color:#a6e22e">Operation</span>
}
     
<span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">this</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">SubOperation</span>) <span style="color:#a6e22e">GetResult</span>() <span style="color:#66d9ef">float64</span> {
    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">this</span>.<span style="color:#a6e22e">a</span> <span style="color:#f92672">-</span> <span style="color:#a6e22e">this</span>.<span style="color:#a6e22e">b</span>
}
     
<span style="color:#75715e">// 乘法
</span><span style="color:#75715e"></span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">MulOperation</span> <span style="color:#66d9ef">struct</span> {
    <span style="color:#a6e22e">Operation</span>
}
     
<span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">this</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">MulOperation</span>) <span style="color:#a6e22e">GetResult</span>() <span style="color:#66d9ef">float64</span> {
    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">this</span>.<span style="color:#a6e22e">a</span> <span style="color:#f92672">*</span> <span style="color:#a6e22e">this</span>.<span style="color:#a6e22e">b</span>
}
     
<span style="color:#75715e">// 除法
</span><span style="color:#75715e"></span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">DivOperation</span> <span style="color:#66d9ef">struct</span> {
    <span style="color:#a6e22e">Operation</span>
}
     
<span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">this</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">DivOperation</span>) <span style="color:#a6e22e">GetResult</span>() <span style="color:#66d9ef">float64</span> {
    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">this</span>.<span style="color:#a6e22e">a</span> <span style="color:#f92672">/</span> <span style="color:#a6e22e">this</span>.<span style="color:#a6e22e">b</span>
}
</code></pre></div></li>
<li>
<p>定义抽象工厂方法，并针对不同的子产品，定义不同具体工厂实现去创建产品</p>
<p>因为工厂方法的概念，就是需要根据抽象的工厂方法，创建具体的工厂方法，来创建具体的子产品。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#75715e">// 抽象工厂interface，内部有抽象方法返回抽象的产品Product
</span><span style="color:#75715e"></span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">IFactory</span> <span style="color:#66d9ef">interface</span> {
    <span style="color:#a6e22e">CreateOperation</span>() <span style="color:#a6e22e">Operation</span>   <span style="color:#75715e">// 抽象工厂方法返回抽象产品
</span><span style="color:#75715e"></span>}
     
     
<span style="color:#75715e">// 创建具体的抽象工厂，创建具体子产品
</span><span style="color:#75715e"></span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">AddFactory</span> <span style="color:#66d9ef">struct</span> {
}
     
<span style="color:#75715e">// 具体抽象工厂，返回具体的子对象
</span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">this</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">AddFactory</span>) <span style="color:#a6e22e">CreateOperation</span>() <span style="color:#a6e22e">OperationI</span> {
    <span style="color:#66d9ef">return</span> <span style="color:#f92672">&amp;</span>(<span style="color:#a6e22e">AddOperation</span>{})
}
</code></pre></div></li>
<li>
<p>Usage使用方式
和标准定义工厂方法模式略有不同，此处是直接创建具体的工厂对象，进而来创建具体的子产品。
因为抽象工厂在golang中是interface类型的，不能直接实例化的。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
    <span style="color:#a6e22e">fac</span> <span style="color:#f92672">:=</span> <span style="color:#f92672">&amp;</span>(<span style="color:#a6e22e">AddFactory</span>{}) <span style="color:#75715e">// 加法工厂
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">oper</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">fac</span>.<span style="color:#a6e22e">CreateOperation</span>() <span style="color:#75715e">// 创建加法对象
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">oper</span>.<span style="color:#a6e22e">SetA</span>(<span style="color:#ae81ff">1</span>)
    <span style="color:#a6e22e">oper</span>.<span style="color:#a6e22e">SetB</span>(<span style="color:#ae81ff">2</span>)
    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">oper</span>.<span style="color:#a6e22e">GetResult</span>())
}
</code></pre></div></li>
</ol>
</li>
</ul>
<h5 id="heading"></h5>

			</div>
                   </br>[content:] end~</br>
		</article>
	</main>
<aside>
	<div>
		<div>
			<h3>LATEST POSTS</h3>
		</div>
		<div>
			<ul>
				
				<li><a href="/post/golang%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0_%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95factorymethod/">Golang设计模式学习_工厂方法FactoryMethod</a></li>
				
				<li><a href="/post/golang%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0_%E5%BB%BA%E9%80%A0%E8%80%85builder/">Golang设计模式学习_建造者builder</a></li>
				
				<li><a href="/post/golang%E4%B8%ADcontext%E7%9A%84%E5%BA%94%E7%94%A8/">Golang中context的应用</a></li>
				
				<li><a href="/post/%E5%8A%A8%E6%80%81%E5%9F%9F%E5%90%8D%E5%88%87%E6%8D%A2/">动态域名切换</a></li>
				
				<li><a href="/post/%E4%B8%AD%E5%8F%B0%E5%AD%A6%E4%B9%A0/">中台学习</a></li>
				
			</ul>
		</div>
	</div>
</aside>


	<footer>
	<p>&copy; 2020 <a href="https://www.xssor2600.site/"><b>琳琅世界，观山河</b></a>.
	<a href="https://github.com/xssor2600"><b>Github</b></a>.
	<a href="https://www.jianshu.com/u/f83bd1cdcfc0"><b>简书</b></a>.
	<a href=""><b>知乎</b></a>.
	</p>
</footer>

</body>
</html>
