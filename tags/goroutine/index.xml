<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>goroutine on 琳琅世界，观山河</title>
    <link>https://www.xssor2600.site/tags/goroutine/</link>
    <description>Recent content in goroutine on 琳琅世界，观山河</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sun, 02 Aug 2020 15:23:52 +0800</lastBuildDate>
    
	<atom:link href="https://www.xssor2600.site/tags/goroutine/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Goroutine学习初见</title>
      <link>https://www.xssor2600.site/post/goroutine%E5%AD%A6%E4%B9%A0%E5%88%9D%E8%A7%81/</link>
      <pubDate>Sun, 02 Aug 2020 15:23:52 +0800</pubDate>
      
      <guid>https://www.xssor2600.site/post/goroutine%E5%AD%A6%E4%B9%A0%E5%88%9D%E8%A7%81/</guid>
      <description>Go 编程语言的目的:
 Go 的目的不是研究编程语言设计; 它是为了改善设计师和同事的工作环境。 Go 比编程语言研究更关注软件工程。 或者换句话说，就是为软件工程师服务的语言设计。
 Go 运行时允许您在机器上运行数十万个并发 goroutine 。Goroutine 是一个轻量级的执行线程。 Go 运行时将这些 goroutine 复用到操作系统线程上。 这意味着多个 goroutine 可以在单个操作系统线程上同时运行。
Go 运行时有一个调度程序，其任务是调度这些 goroutine 执行。
 1:初始化时的 Goroutine 具有 2KB 的堆栈。与一个一般为 1 MB 的 OS 线程堆栈相比，这非常小巧。当你需要同时运行几十万个不同的 goroutine 时，这个数字很重要。如果你要并行运行数千个 OS 线程，RAM 显然将成为瓶颈。 2:Go 可以遵循与 Java 等其他语言相同的模型，它支持与 OS 线程相同的线程概念。但是在这种情况下，OS 线程之间的上下文切换成本比不同的 goroutine 之间的上下文切换成本要大得多。
 </description>
    </item>
    
  </channel>
</rss>